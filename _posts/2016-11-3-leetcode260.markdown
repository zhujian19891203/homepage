---
layout:     post
title:      "Leetcode 260"
subtitle:   "Single Number III"
date:       2016-11-3
author:     "Zhu Jian"
header-img: "img/leetcode-bg.jpg"
tags:
    - Leetcode
    - Algorithm
---

## Single Number III

#### 题目
Given an array of numbers `nums`, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.  
For example:  
Given `nums = [1, 2, 1, 3, 2, 5]`, return `[3, 5]`.

##### Note
1. The order of the result is not important. So in the above example, [5, 3] is also correct.
2. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?

#### 解题思路
**关键：**  

* 可以将数组中所有数进行异或操作，结果将是只出现一次的两个数异或的结果。对于结果，必定能找出某一位为1，意味着这两个数在该位置处的二进制数值不相同，因此可以将其作为标准将整个数组分为两大块
* 使用Leetcode 136的方法分别得出两个数

#### Code
```
public class Leetcode {
    public int[] singleNumber(int[] nums) {
        int[] res = new int[2];

        int len = nums.length;

        int xor_res = 0;
        for(int i = 0; i < len; i++) {
            xor_res ^= nums[i];
        }

        int idx = -1;
        for(int i = 0; i < 32; i++) {
            if(((xor_res >> i) & 1) == 1) {
                idx = i;
                break;
            }
        }

        int xor_res_twice = 0;
        for(int i = 0; i < len; i++) {
            if(((nums[i] >> idx) & 1) == 1) {
                xor_res_twice ^= nums[i];
            }
        }

        res[0] = xor_res_twice;
        res[1] = xor_res ^ xor_res_twice;

        return res;
    }
}

```